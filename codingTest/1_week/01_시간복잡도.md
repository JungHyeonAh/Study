# 시간복잡도

> 입력크기에 대해 어떤 알고리즘이 실행되는데 걸리는 시간이다.   
> **주요 로직의 반복횟수를 중점**으로 측정된다.   
   
```
ex)
console.time("test")

let a = 0   
for(let i=0; i<100; i++) {   
    a += i;   
}   
console.timeEnd("test")   
```

* 이와 같은 코드가 있을 때 console.time 코드를 사용해서 시간을 측정할 경우   
  -> 컴퓨터 사양 등 여러 요소들로 인해 시간이 다 다르게 측정이 된다.   
**때문에 주요 로직이 몇번 반복되었는지를 기준으로 측정한다.**   

***

```
for(int i = 0; i < 10; i++){   
	for(int j =0; j < n; j++){   
		for(int k = 0; k < n; k++){   
			if(true) cout << k << '\n';   
		}   
	}   
}   
for(int i = 0; i < n; i++){   
	if(true) cout << i << '\n';   
}   
```
* 이 코드의 시간복잡도는 어떻게 될까?   
- if(true) cout << k << '\n'; 란 코드가 반복이 되고 있다. 이 코드를 기준으로 거꾸로 계산을 하게 되면   
  **10 n^2 + n** 이란 값을 가지게 된다.
  ```
  for(int i = 0; i < 10; i++){ -> 10번 반복 => n * n * 10   
	for(int j =0; j < n; j++){ -> n번 반복 => n * n   
		for(int k = 0; k < n; k++){ -> n번 반복   
			if(true) cout << k << '\n';   
			}   
		}   
	}   
   for(int i = 0; i < n; i++){ -> n번 반복하지만, 10번 for문 밖에 있음. => + n  
	if(true) cout << i << '\n';   
   }
  결과 = (10 * n * n) + n = (10 * n^2) + n
  ```
  
***
## 상수시간 시간복잡도( O(1) )
+ 입력크기와 상관없이 일정한 시간복잡도를 가지는 것을 의미한다.
  - **O(1)** 의 시간복잡도를 쓴다.   

위의 코드에서 n의 값이 10이든 1000이든 시간복잡도가 **(10 * n^2) + n** 란 사실은 동일하다.   

```
O(1) 시간복잡도인 것들
1. 입출력 (cin, cout, scanf, printf)
2. 곱하기 ( * )
3. 간단한 비교 if문 ( if(a[0] == 1) )
4. 배열의 인덱스 참조 ( int a[2] = {1, 2};  int b = a[0]; )
```
